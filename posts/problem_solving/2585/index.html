<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[BOJ][Python] 2585번: 경비행기 | Just For Fun</title><meta name=keywords content><meta name=description content="사설 오랜만에 백준을 풀었다. 카페에 노트북을 들고 가 무어라도 하려고 할 마음이면, 가장 부담없이 카페의 생산성 기대치를 만족시킬 수 있는 것은 알고리즘 풀이이다. 그렇게 난 오늘도 백준을 킨다&mldr;⭐️
가벼운 마음으로 내가 실패한 문제에서 골드2 문제를 골랐다. 1년전 오답을 제출한 기록이 있었고, 굳이 오답을 확인하지 않았다. 오롯이 현재의 내 능력으로 문제를 풀고 싶었다.
문제 풀이 문제 링크.
급유할 수 있는 경유지들이 2차원 좌표로 주어지고 급유의 횟수가 제한 될 때, 목적지까지 가기 위한 최소의 연료통을 구하는 문제이다."><meta name=author content><link rel=canonical href=https://ojhoney.github.io/posts/problem_solving/2585/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.bccfefac377bc340f06c260aed1bddf49a4354816d7c570d6aac75a997986c95.css integrity="sha256-vM/vrDd7w0DwbCYK7Rvd9JpDVIFtfFcNaqx1qZeYbJU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://ojhoney.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ojhoney.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ojhoney.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ojhoney.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ojhoney.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="[BOJ][Python] 2585번: 경비행기"><meta property="og:description" content="사설 오랜만에 백준을 풀었다. 카페에 노트북을 들고 가 무어라도 하려고 할 마음이면, 가장 부담없이 카페의 생산성 기대치를 만족시킬 수 있는 것은 알고리즘 풀이이다. 그렇게 난 오늘도 백준을 킨다&mldr;⭐️
가벼운 마음으로 내가 실패한 문제에서 골드2 문제를 골랐다. 1년전 오답을 제출한 기록이 있었고, 굳이 오답을 확인하지 않았다. 오롯이 현재의 내 능력으로 문제를 풀고 싶었다.
문제 풀이 문제 링크.
급유할 수 있는 경유지들이 2차원 좌표로 주어지고 급유의 횟수가 제한 될 때, 목적지까지 가기 위한 최소의 연료통을 구하는 문제이다."><meta property="og:type" content="article"><meta property="og:url" content="https://ojhoney.github.io/posts/problem_solving/2585/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-07-08T00:00:00+00:00"><meta property="article:modified_time" content="2023-07-08T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="[BOJ][Python] 2585번: 경비행기"><meta name=twitter:description content="사설 오랜만에 백준을 풀었다. 카페에 노트북을 들고 가 무어라도 하려고 할 마음이면, 가장 부담없이 카페의 생산성 기대치를 만족시킬 수 있는 것은 알고리즘 풀이이다. 그렇게 난 오늘도 백준을 킨다&mldr;⭐️
가벼운 마음으로 내가 실패한 문제에서 골드2 문제를 골랐다. 1년전 오답을 제출한 기록이 있었고, 굳이 오답을 확인하지 않았다. 오롯이 현재의 내 능력으로 문제를 풀고 싶었다.
문제 풀이 문제 링크.
급유할 수 있는 경유지들이 2차원 좌표로 주어지고 급유의 횟수가 제한 될 때, 목적지까지 가기 위한 최소의 연료통을 구하는 문제이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://ojhoney.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Problem Solving","item":"https://ojhoney.github.io/posts/problem_solving/"},{"@type":"ListItem","position":4,"name":"[BOJ][Python] 2585번: 경비행기","item":"https://ojhoney.github.io/posts/problem_solving/2585/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[BOJ][Python] 2585번: 경비행기","name":"[BOJ][Python] 2585번: 경비행기","description":"사설 오랜만에 백준을 풀었다. 카페에 노트북을 들고 가 무어라도 하려고 할 마음이면, 가장 부담없이 카페의 생산성 기대치를 만족시킬 수 있는 것은 알고리즘 풀이이다. 그렇게 난 오늘도 백준을 킨다\u0026hellip;⭐️\n가벼운 마음으로 내가 실패한 문제에서 골드2 문제를 골랐다. 1년전 오답을 제출한 기록이 있었고, 굳이 오답을 확인하지 않았다. 오롯이 현재의 내 능력으로 문제를 풀고 싶었다.\n문제 풀이 문제 링크.\n급유할 수 있는 경유지들이 2차원 좌표로 주어지고 급유의 횟수가 제한 될 때, 목적지까지 가기 위한 최소의 연료통을 구하는 문제이다.","keywords":[],"articleBody":"사설 오랜만에 백준을 풀었다. 카페에 노트북을 들고 가 무어라도 하려고 할 마음이면, 가장 부담없이 카페의 생산성 기대치를 만족시킬 수 있는 것은 알고리즘 풀이이다. 그렇게 난 오늘도 백준을 킨다…⭐️\n가벼운 마음으로 내가 실패한 문제에서 골드2 문제를 골랐다. 1년전 오답을 제출한 기록이 있었고, 굳이 오답을 확인하지 않았다. 오롯이 현재의 내 능력으로 문제를 풀고 싶었다.\n문제 풀이 문제 링크.\n급유할 수 있는 경유지들이 2차원 좌표로 주어지고 급유의 횟수가 제한 될 때, 목적지까지 가기 위한 최소의 연료통을 구하는 문제이다. 경유지간 거리는 실수로 표현되지만, 연료 소모량은 정수인 점에서 부자연스러움을 느꼈다. 연료주입은 리터 단위로 한다 라는 문제의 설명만으로는 부족한 것 같다. 연료소모 또한 리터 단위라는 조건이 추가되어야 한다고 생각한다.\n출발지가 $S=(0, 0)$, 목적지가 $T=(10000, 10000)$ 으로 정해져 있으므로 급유횟수 $k$와 상관없이 연료통이 1415리터이면 출발지에서 목적지까지 갈 수 있다. 가능한 답의 하한과 상한이 정해져있고 (0과 1415 사이) 찾으려는 답이 이산적이면 (정수 조건) 가장 먼저 떠오르는 알고리즘은 이분탐색이다.\n이분탐색으로 문제를 풀기위해서는 결정문제를 정의하고 풀어야 한다. 이 문제에서의 결정문제는 연료통 용량이 $c$일 때 $k$번 이하로 중간급유하여 출발지에서 목적지까지 갈 수 있나 이다. 그래프 탐색 알고리즘을 이용하면 이 결정문제를 해결할 수 있다.\n막연하게 생각했을 때, 불필요한 경유지를 최대한 방문하지 않고 출발지에서 목적지까지 가야하기때문에 BFS로 구현하고자 했다. 큐에 (경유지 인덱스, 남은 연료, 남은 연료충전횟수) 를 저장하여 갈 수 있는 경유지를 탐색하였다. 남은 연료로 갈 수 있는 경유, 연료를 충전해서 갈 수 있는 경유를 나눠서 구현하였다. 결정문제를 해결하였으므로 이분탐색으로 최소 연료통을 구했다. AC받은 코드는 아래와 같다.\nimport sys; readline = sys.stdin.readline from collections import deque import math S = (0, 0) T = (10000, 10000) def can_fly(capacity, K, distances): visited = [False] * (N+2) queue = deque() # 현재 경유지 인덱스, 남은 연료, 남은 연료충전횟수 queue.append((0, capacity, K)) visited[0] = True while queue: node, gas, k = queue.popleft() if node == N+1: return True for next_node in range(N+2): if visited[next_node]: continue gas_needed = math.ceil(distances[node][next_node]/10) if capacity \u003c gas_needed: continue if gas \u003c gas_needed: if k == 0: continue queue.append((next_node, capacity-gas_needed, k-1)) visited[next_node] = True else: queue.append((next_node, gas-gas_needed, k)) visited[next_node] = True return False def binary_search(K, distances): lo = 0 hi = 1415 ans = hi while lo \u003c= hi: mid = (lo+hi)//2 if can_fly(mid, K, distances): ans = mid hi = mid-1 else: lo = mid+1 return ans if __name__ == \"__main__\": N, K = map(int, readline().split()) stops = [S] distances = [[0] * (N+2) for _ in range(N+2)] for _ in range(N): x, y = map(int, readline().split()) stops.append((x, y)) stops.append(T) for i in range(N+2): for j in range(i+1, N+2): d = math.dist(stops[i], stops[j]) distances[i][j] = d distances[j][i] = d ans = binary_search(K, distances) print(ans) 반례 발견? AC받은 코드를 검토하던 중, 흥미로운 점을 발견했다. 주어진 연료통으로 도착지까지 갈 수 있는지 판별하는 함수 can_fly에서 나는 경유지들에 대한 방문 처리를 boolean array로 구현하였다. 하지만, 단순히 방문 여부만 확인해서는 더 적은 연료로 해당 경유지까지 갈 수 있는 경로를 무시한다는 것을 발견하였다. 예를 들어, 아래와 같은 예제를 고려해보자.\nC (40, 70) B'(0, 40) A-B = 4연료 A-B' = 4연료 B-C = 7연료 B'-C = 5연료 A (0, 0) B (40, 0) A-C \u003e 8연료 -------------------------- 사용할 수 있는 연료통이 8 이라고 하면, A-C는 불가능하고 B나 B'를 경유해야한다.\nA-B-C 경로로 C에 도착할 경우 (남은 연료=1, 충전 횟수=1) 이고 A-B'-C 경로로 C에 도착할 경우 (남은 연료=3, 충전 횟수=1) 이다.\nA-B'-C 경로를 이용했을 때, 현재 남은 연료가 더 많다. 하지만 내가 구현한 can_fly 함수에서 처럼 단순히 boolean array로 방문처리를 하고 B가 B'가 탐색 큐에 먼저 들어간다면, C를 더 나은 조건(많이 남아있는 연료)으로 방문할 수 없게 된다.\n이 사실을 처음 발견했을 때 나는 내가 AC 받은 코드가 틀렸다고 확신했고, 반례를 찾아 백준에 데이터 추가를 요청할 생각에 신났었다. 이미 출제된지 오래인 무려 2000번대 문제에 반례를 찾다니!\n발견 실패 반례를 찾기 위해 노력을 했지만 실패했다. 원하는데로 테스트 케이스가 만들어지지 않았다. 위의 예제에서 내가 원하는 테스트케이스는 A-B'-C 경로 (남은 연료=3)로는 다음 경유지에 갈 수 있지만 A-B-C 경로 (남은 연료=1)에서는 갈 수 없는 상황이다. 이를 위해 다음 경유지 D를 1연료 \u003c C-D \u003c= 3연료로 설정하고자 했지만, 이는 불가능하다는 결론을 내렸다.\nC에서 연료를 충전하지 않고 다음 경유지로 갈 수 있는 경우는, 유클리드 거리의 삼각 부등식덕에 B'-C-D가 가능하면 B'-D도 가능하다. 즉 C의 방문 여부는 중요하지않다.\n만약 C에서 연료를 충전해야한다면, C에서의 남은 연료량은 중요하지 않다.\n경유지별로 남은 연료를 저장하지 않고 방문여부만 저장해도 이 2585번 문제를 풀기에는 충분하다.\n만약 경유지간의 거리가 삼각부등식을 만족하지 않는다면, 경유지별로 최대 남은 연료를 기록하고 경로마다 비교하여 갱신해야할 것이다.\n결론 반례를 찾았다는 생각에 오랜 시간 삽질을 했다. 하지만 충분히 의미있는 삽질이었다. AC를 받았다고 휘리릭 다음문제로 넘어갔다면, 왜 방문처리를 boolean array로만 해도 되는지, 삼각 부등식이 중요한 조건인지 알아낼 수 없었을 것이다. 이미 짠 코드라도 다시 한번 살펴보고 완전히 이해하려는 습관은 나의 장점 중 하나라고 생각한다. 비록 시간은 오래걸리더라도 이러한 습관을 유지하고 발전시키자.\n","wordCount":"747","inLanguage":"en","datePublished":"2023-07-08T00:00:00Z","dateModified":"2023-07-08T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://ojhoney.github.io/posts/problem_solving/2585/"},"publisher":{"@type":"Organization","name":"Just For Fun","logo":{"@type":"ImageObject","url":"https://ojhoney.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ojhoney.github.io accesskey=h title="JustForFun (Alt + H)"><img src=https://ojhoney.github.io/apple-touch-icon.png alt aria-label=logo height=35>JustForFun</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ojhoney.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://ojhoney.github.io/posts title=Posts><span>Posts</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ojhoney.github.io>Home</a>&nbsp;»&nbsp;<a href=https://ojhoney.github.io/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://ojhoney.github.io/posts/problem_solving/>Problem Solving</a></div><h1 class=post-title>[BOJ][Python] 2585번: 경비행기</h1><div class=post-meta><span title='2023-07-08 00:00:00 +0000 UTC'>July 8, 2023</span>&nbsp;|&nbsp;<a href=https://github.com/ojhoney/ojhoney.github.io/tree/main/content/posts/problem_solving/2585.md rel="noopener noreferrer" target=_blank>Markdown</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#사설>사설</a></li><li><a href=#문제--풀이>문제 풀이</a></li><li><a href=#반례-발견>반례 발견?</a></li><li><a href=#발견-실패>발견 실패</a></li><li><a href=#결론>결론</a></li></ul></nav></div></details></div><div class=post-content><h2 id=사설>사설<a hidden class=anchor aria-hidden=true href=#사설>#</a></h2><p>오랜만에 백준을 풀었다. 카페에 노트북을 들고 가 무어라도 하려고 할 마음이면, 가장 부담없이 카페의 생산성 기대치를 만족시킬 수 있는 것은 알고리즘 풀이이다. 그렇게 난 오늘도 백준을 킨다&mldr;⭐️</p><p>가벼운 마음으로 <code>내가 실패한 문제</code>에서 골드2 문제를 골랐다. 1년전 오답을 제출한 기록이 있었고, 굳이 오답을 확인하지 않았다. 오롯이 현재의 내 능력으로 문제를 풀고 싶었다.</p><h2 id=문제--풀이>문제 풀이<a hidden class=anchor aria-hidden=true href=#문제--풀이>#</a></h2><p><a href=https://www.acmicpc.net/problem/2585>문제 링크</a>.</p><p>급유할 수 있는 경유지들이 2차원 좌표로 주어지고 급유의 횟수가 제한 될 때, 목적지까지 가기 위한 최소의 연료통을 구하는 문제이다. 경유지간 거리는 실수로 표현되지만, 연료 소모량은 정수인 점에서 부자연스러움을 느꼈다. <em>연료주입은 리터 단위로 한다</em> 라는 문제의 설명만으로는 부족한 것 같다. 연료소모 또한 리터 단위라는 조건이 추가되어야 한다고 생각한다.</p><p>출발지가 $S=(0, 0)$, 목적지가 $T=(10000, 10000)$ 으로 정해져 있으므로 급유횟수 $k$와 상관없이 연료통이 1415리터이면 출발지에서 목적지까지 갈 수 있다. 가능한 답의 하한과 상한이 정해져있고 (0과 1415 사이) 찾으려는 답이 이산적이면 (정수 조건) 가장 먼저 떠오르는 알고리즘은 이분탐색이다.</p><p>이분탐색으로 문제를 풀기위해서는 결정문제를 정의하고 풀어야 한다. 이 문제에서의 결정문제는 <em>연료통 용량이 $c$일 때 $k$번 이하로 중간급유하여 출발지에서 목적지까지 갈 수 있나</em> 이다. 그래프 탐색 알고리즘을 이용하면 이 결정문제를 해결할 수 있다.</p><p>막연하게 생각했을 때, 불필요한 경유지를 최대한 방문하지 않고 출발지에서 목적지까지 가야하기때문에 BFS로 구현하고자 했다. 큐에 <code>(경유지 인덱스, 남은 연료, 남은 연료충전횟수)</code> 를 저장하여 갈 수 있는 경유지를 탐색하였다. 남은 연료로 갈 수 있는 경유, 연료를 충전해서 갈 수 있는 경유를 나눠서 구현하였다. 결정문제를 해결하였으므로 이분탐색으로 최소 연료통을 구했다. AC받은 코드는 아래와 같다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>sys</span><span class=p>;</span> <span class=n>readline</span> <span class=o>=</span> <span class=n>sys</span><span class=o>.</span><span class=n>stdin</span><span class=o>.</span><span class=n>readline</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>collections</span> <span class=kn>import</span> <span class=n>deque</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>math</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>S</span> <span class=o>=</span> <span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>T</span> <span class=o>=</span> <span class=p>(</span><span class=mi>10000</span><span class=p>,</span> <span class=mi>10000</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>can_fly</span><span class=p>(</span><span class=n>capacity</span><span class=p>,</span> <span class=n>K</span><span class=p>,</span> <span class=n>distances</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>visited</span> <span class=o>=</span> <span class=p>[</span><span class=kc>False</span><span class=p>]</span> <span class=o>*</span> <span class=p>(</span><span class=n>N</span><span class=o>+</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>queue</span> <span class=o>=</span> <span class=n>deque</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1># 현재 경유지 인덱스, 남은 연료, 남은 연료충전횟수</span>
</span></span><span class=line><span class=cl>    <span class=n>queue</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=mi>0</span><span class=p>,</span> <span class=n>capacity</span><span class=p>,</span> <span class=n>K</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=n>visited</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>queue</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>node</span><span class=p>,</span> <span class=n>gas</span><span class=p>,</span> <span class=n>k</span> <span class=o>=</span> <span class=n>queue</span><span class=o>.</span><span class=n>popleft</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>node</span> <span class=o>==</span> <span class=n>N</span><span class=o>+</span><span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>next_node</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>N</span><span class=o>+</span><span class=mi>2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>visited</span><span class=p>[</span><span class=n>next_node</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=k>continue</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=n>gas_needed</span> <span class=o>=</span> <span class=n>math</span><span class=o>.</span><span class=n>ceil</span><span class=p>(</span><span class=n>distances</span><span class=p>[</span><span class=n>node</span><span class=p>][</span><span class=n>next_node</span><span class=p>]</span><span class=o>/</span><span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>capacity</span> <span class=o>&lt;</span> <span class=n>gas_needed</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>continue</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>gas</span> <span class=o>&lt;</span> <span class=n>gas_needed</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>k</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=k>continue</span>
</span></span><span class=line><span class=cl>                <span class=n>queue</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>next_node</span><span class=p>,</span> <span class=n>capacity</span><span class=o>-</span><span class=n>gas_needed</span><span class=p>,</span> <span class=n>k</span><span class=o>-</span><span class=mi>1</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                <span class=n>visited</span><span class=p>[</span><span class=n>next_node</span><span class=p>]</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>queue</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>next_node</span><span class=p>,</span> <span class=n>gas</span><span class=o>-</span><span class=n>gas_needed</span><span class=p>,</span> <span class=n>k</span><span class=p>))</span>             
</span></span><span class=line><span class=cl>                <span class=n>visited</span><span class=p>[</span><span class=n>next_node</span><span class=p>]</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>binary_search</span><span class=p>(</span><span class=n>K</span><span class=p>,</span> <span class=n>distances</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>lo</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=n>hi</span> <span class=o>=</span> <span class=mi>1415</span>
</span></span><span class=line><span class=cl>    <span class=n>ans</span> <span class=o>=</span> <span class=n>hi</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>lo</span> <span class=o>&lt;=</span> <span class=n>hi</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>mid</span> <span class=o>=</span> <span class=p>(</span><span class=n>lo</span><span class=o>+</span><span class=n>hi</span><span class=p>)</span><span class=o>//</span><span class=mi>2</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>can_fly</span><span class=p>(</span><span class=n>mid</span><span class=p>,</span> <span class=n>K</span><span class=p>,</span> <span class=n>distances</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>ans</span> <span class=o>=</span> <span class=n>mid</span>
</span></span><span class=line><span class=cl>            <span class=n>hi</span> <span class=o>=</span> <span class=n>mid</span><span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>lo</span> <span class=o>=</span> <span class=n>mid</span><span class=o>+</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ans</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s2>&#34;__main__&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>N</span><span class=p>,</span> <span class=n>K</span> <span class=o>=</span> <span class=nb>map</span><span class=p>(</span><span class=nb>int</span><span class=p>,</span> <span class=n>readline</span><span class=p>()</span><span class=o>.</span><span class=n>split</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=n>stops</span> <span class=o>=</span> <span class=p>[</span><span class=n>S</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>distances</span> <span class=o>=</span> <span class=p>[[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=p>(</span><span class=n>N</span><span class=o>+</span><span class=mi>2</span><span class=p>)</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>N</span><span class=o>+</span><span class=mi>2</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>N</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>x</span><span class=p>,</span> <span class=n>y</span> <span class=o>=</span> <span class=nb>map</span><span class=p>(</span><span class=nb>int</span><span class=p>,</span> <span class=n>readline</span><span class=p>()</span><span class=o>.</span><span class=n>split</span><span class=p>())</span>
</span></span><span class=line><span class=cl>        <span class=n>stops</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>stops</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>T</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>N</span><span class=o>+</span><span class=mi>2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=n>N</span><span class=o>+</span><span class=mi>2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>d</span> <span class=o>=</span> <span class=n>math</span><span class=o>.</span><span class=n>dist</span><span class=p>(</span><span class=n>stops</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>stops</span><span class=p>[</span><span class=n>j</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=n>distances</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>d</span>
</span></span><span class=line><span class=cl>            <span class=n>distances</span><span class=p>[</span><span class=n>j</span><span class=p>][</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>d</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>ans</span> <span class=o>=</span> <span class=n>binary_search</span><span class=p>(</span><span class=n>K</span><span class=p>,</span> <span class=n>distances</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>ans</span><span class=p>)</span>        
</span></span></code></pre></div><h2 id=반례-발견>반례 발견?<a hidden class=anchor aria-hidden=true href=#반례-발견>#</a></h2><p>AC받은 코드를 검토하던 중, 흥미로운 점을 발견했다. 주어진 연료통으로 도착지까지 갈 수 있는지 판별하는 함수 <code>can_fly</code>에서 나는 경유지들에 대한 방문 처리를 boolean array로 구현하였다. 하지만, 단순히 방문 여부만 확인해서는 더 적은 연료로 해당 경유지까지 갈 수 있는 경로를 무시한다는 것을 발견하였다. 예를 들어, 아래와 같은 예제를 고려해보자.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>                C (40, 70)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>B&#39;(0, 40)                       A-B = 4연료        
</span></span><span class=line><span class=cl>                                A-B&#39; = 4연료
</span></span><span class=line><span class=cl>                                B-C = 7연료
</span></span><span class=line><span class=cl>                                B&#39;-C = 5연료
</span></span><span class=line><span class=cl>A (0, 0)        B (40, 0)       A-C &gt; 8연료                        
</span></span><span class=line><span class=cl>--------------------------
</span></span></code></pre></div><p><strong>사용할 수 있는 연료통이 8</strong> 이라고 하면, <code>A-C</code>는 불가능하고 <code>B</code>나 <code>B'</code>를 경유해야한다.</p><p><code>A-B-C</code> 경로로 C에 도착할 경우 <code>(남은 연료=1, 충전 횟수=1)</code> 이고 <code>A-B'-C</code> 경로로 C에 도착할 경우 <code>(남은 연료=3, 충전 횟수=1)</code> 이다.</p><p><code>A-B'-C</code> 경로를 이용했을 때, 현재 남은 연료가 더 많다. 하지만 내가 구현한 <code>can_fly</code> 함수에서 처럼 단순히 boolean array로 방문처리를 하고 <code>B</code>가 <code>B'</code>가 탐색 큐에 먼저 들어간다면, <code>C</code>를 더 나은 조건(많이 남아있는 연료)으로 방문할 수 없게 된다.</p><p>이 사실을 처음 발견했을 때 나는 내가 AC 받은 코드가 틀렸다고 확신했고, 반례를 찾아 백준에 데이터 추가를 요청할 생각에 신났었다. 이미 출제된지 오래인 무려 2000번대 문제에 반례를 찾다니!</p><h2 id=발견-실패>발견 실패<a hidden class=anchor aria-hidden=true href=#발견-실패>#</a></h2><p>반례를 찾기 위해 노력을 했지만 실패했다. 원하는데로 테스트 케이스가 만들어지지 않았다. 위의 예제에서 내가 원하는 테스트케이스는 <code>A-B'-C</code> 경로 <code>(남은 연료=3)</code>로는 다음 경유지에 갈 수 있지만 <code>A-B-C</code> 경로 <code>(남은 연료=1)</code>에서는 갈 수 없는 상황이다. 이를 위해 다음 경유지 <code>D</code>를 <code>1연료 &lt; C-D &lt;= 3연료</code>로 설정하고자 했지만, 이는 불가능하다는 결론을 내렸다.</p><blockquote><p><code>C</code>에서 연료를 충전하지 않고 다음 경유지로 갈 수 있는 경우는, <strong>유클리드 거리의 삼각 부등식</strong>덕에 <code>B'-C-D</code>가 가능하면 <code>B'-D</code>도 가능하다. 즉 C의 방문 여부는 중요하지않다.</p><p>만약 <code>C</code>에서 연료를 충전해야한다면, <code>C</code>에서의 남은 연료량은 중요하지 않다.</p></blockquote><p>경유지별로 남은 연료를 저장하지 않고 방문여부만 저장해도 이 2585번 문제를 풀기에는 충분하다.</p><p>만약 경유지간의 거리가 삼각부등식을 만족하지 않는다면, 경유지별로 최대 남은 연료를 기록하고 경로마다 비교하여 갱신해야할 것이다.</p><h2 id=결론>결론<a hidden class=anchor aria-hidden=true href=#결론>#</a></h2><p>반례를 찾았다는 생각에 오랜 시간 삽질을 했다. 하지만 충분히 의미있는 삽질이었다. AC를 받았다고 휘리릭 다음문제로 넘어갔다면, 왜 방문처리를 boolean array로만 해도 되는지, 삼각 부등식이 중요한 조건인지 알아낼 수 없었을 것이다. 이미 짠 코드라도 다시 한번 살펴보고 완전히 이해하려는 습관은 나의 장점 중 하나라고 생각한다. 비록 시간은 오래걸리더라도 이러한 습관을 유지하고 발전시키자.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://ojhoney.github.io>Just For Fun</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>